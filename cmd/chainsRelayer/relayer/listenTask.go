package relayer

import (
	"context"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/log"
	"github.com/syndtr/goleveldb/leveldb"
	"math/big"
	"time"
)

type ListenTask interface {
	running(co *ChainOperator)
	isStart() bool
	stop()
}

type ListenEventTask struct {
	start     bool
	address   common.Address
	eventName string

	// independentReceiveChan event data will be transmitted back through this pipeline When listenTask receive data
	independentReceiveChan chan types.Log
	// sub represents an event subscription where events are delivered on a data channel.
	sub ethereum.Subscription

	// handleFunc defines the process of receiving event data
	handleFunc func(log2 types.Log)

	ctx context.Context
	// cancleFunc is generated by the context.withCancle(ctx)
	cancleFunc func()
}

func NewListenEventTask(address common.Address, eventName string, recChan chan types.Log, subscription ethereum.Subscription, sCtx context.Context, cf func()) *ListenEventTask {
	return &ListenEventTask{start: true, address: address, eventName: eventName, independentReceiveChan: recChan, sub: subscription, ctx: sCtx, cancleFunc: cf}
}

func (he *ListenEventTask) setIndependentReceiveChan(c chan types.Log) {
	he.independentReceiveChan = c
}

func (task *ListenEventTask) isStart() bool {
	return task.start
}

func (task *ListenEventTask) stop() {
	task.start = false
	task.sub.Unsubscribe()
	task.cancleFunc()
}

func (task *ListenEventTask) running(co *ChainOperator) {
	for {
		if !task.start {
			break
		}
		select {
		case logData := <-task.independentReceiveChan:
			log.Info("【ListenTask】 receives log", "event name", task.eventName, "contract address", logData.Address, "tx hash", logData.TxHash)
			if task.handleFunc != nil {
				go task.handleFunc(logData)
			}
		case err := <-task.sub.Err():
			log.Error("【ListenTask】happens error", "event name", task.eventName, "err", err)
			task.sub.Unsubscribe()
			co.reSubscribeEvent(task)
		case <-task.ctx.Done():
			delete(co.contracts[task.address].HandleEventList, co.contracts[task.address].getEventId(task.eventName))
			task.sub.Unsubscribe()
			task.start = false

			log.Info("【ListenTask】 quit ", "event", task.eventName)
			return
		default:
			log.Info("【ListenTask】 working", "event", task.eventName)
			time.Sleep(10 * time.Second)

		}
	}
}

type CommonListenTask struct {
	name          string
	start         bool
	ctx           context.Context
	cancleFunc    func()
	receiveChan   chan interface{}
	handleFunc    func(val interface{})
	sub           ethereum.Subscription
	sleepDuration time.Duration
}

func NewCommonListenTask(name string, ctx context.Context, cf func(), receiveChan chan interface{}, sub ethereum.Subscription, sleepDuration time.Duration, handleFunc func(val interface{})) *CommonListenTask {
	return &CommonListenTask{name: name, start: true, ctx: ctx, cancleFunc: cf, receiveChan: receiveChan, sub: sub, sleepDuration: sleepDuration, handleFunc: handleFunc}
}

func (task *CommonListenTask) running(co *ChainOperator) {
	for {
		select {
		case val := <-task.receiveChan:
			log.Info("【CommonListenTask】receive value", "task name", task.name)
			if task.handleFunc != nil {
				go task.handleFunc(val)
			}
		case err := <-task.sub.Err():
			log.Error("【CommonListenTask】receive error", "task name", task.name, "err", err)
			task.sub.Unsubscribe()
			return
		case <-task.ctx.Done():
			task.sub.Unsubscribe()
			//task.start = false
			log.Info("【CommonListenTask】 quit ", "task name", task.name)
			return
		default:
			log.Info("【CommonListenTask】 listening", "task name", task.name)
			time.Sleep(task.sleepDuration)

		}
	}
}

func (task *CommonListenTask) isStart() bool {
	return task.start
}

func (task *CommonListenTask) stop() {
	if !task.start {
		return
	}
	task.start = false
	if task.cancleFunc != nil {
		task.cancleFunc()
	}
}

const Web3QBlockTime = 5 * time.Second

func getLatestHeadLoop(headChan chan interface{}, w3q *ChainOperator) func(<-chan struct{}) error {
	return func(unSubscribe <-chan struct{}) error {
		for {
			select {
			case <-unSubscribe:
				log.Info("getLatestHeadLoop: unSubscribe latest head")
				return nil
			default:
				// don't do anything
			}

			// get latestBlockNumber
			latestHead, err := w3q.Executor.HeaderByNumber(w3q.Ctx, nil)
			if err != nil {
				return err
			}
			log.Info("getLatestHeadLoop:get latest head", "headNumber", latestHead.Number.String())

			//if latestHead.Number.Cmp(big.NewInt(0)) != 0 {
			// store the blockNumber of lastestHeader in db
			key := []byte("latestHead")
			bn, dberr := w3q.db.Get(key)
			if dberr != nil {
				if dberr != leveldb.ErrNotFound {
					log.Error("getLatestHeadLoop:get db error", "error", dberr.Error())
					return err
				}
			}

			//Verify whether the latest block header is stored in the database
			if big.NewInt(0).SetBytes(bn).Cmp(latestHead.Number) < 0 {
				log.Info("getLatestHeadLoop:set latestHeader number at db", "headNumber", latestHead.Number.String())
				log.Warn("Entry HeadChan", "time", time.Now())
				headChan <- latestHead
				log.Warn("Outry HeadChan", "time", time.Now())
				err = w3q.db.Put(key, latestHead.Number.Bytes())
				if err != nil {
					return err
				}
			}
			log.Info("getLatestHeadLoop:sleep", "headNumber", latestHead.Number.String())

			time.Sleep(Web3QBlockTime)
		}
	}
}

func CreateListeningW3qLatestBlockTask(w3q *ChainOperator, eth *ChainOperator, lightClientAddr common.Address, w3qNativeAddr common.Address, w3qErc20Addr common.Address, ctx context.Context) (*CommonListenTask, error) {

	subCtx, cancelFunc := context.WithCancel(ctx)
	headChan := make(chan interface{}, 0)

	// getLatestHead will be executed here
	subscription := event.NewSubscription(getLatestHeadLoop(headChan, w3q))

	// the blockNumber should be submited to LightClient Contract
	return NewCommonListenTask("Get W3qLatestBlock Task", subCtx, cancelFunc, headChan, subscription, 3*time.Second, eth.SendBatchMintForBridgeTokenWhenSubmitHeaderTx(w3q, lightClientAddr, w3qNativeAddr, w3qErc20Addr)), nil

}
